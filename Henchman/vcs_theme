#!/bin/echo Please use source 

print 'Setting up for vcs info themes'
setopt promptsubst
autoload -Uz vcs_info
function precmd() { vcs_info henchman }

local branch action
zstyle -s ':henchman:vcs:color:' branch branch
zstyle -s ':henchman:vcs:color:' action action

format="(%B%F{$branch}%b%f%%b%u%c)"
change_format="(%B%F{$branch}%b%f%%b%u|%c)"
actionformat="(%B%F{$branch}%b%f%%b|%F{$action}%a%f%u%c)"
change_actionformat="(%B%F{$branch}%b%f%%b:%F{$action}%a%f%u|%c)"
not_smart='[%s]-'
not_smart_mark='%1{ᴤ%}'
no_vcs_mark='%#'
# default repo format:
zstyle ':vcs_info:*:henchman:*' max-exports 2
zstyle ':vcs_info:*:henchman:*' formats $not_smart_mark $not_smart$format
zstyle ':vcs_info:*:henchman:*' actionformats $not_smart_mark $not_smart$actionformat
zstyle ':vcs_info:*:henchman:*' nvcsformats $no_vcs_mark

typeset -a sm
zstyle -g sm ':henchman:vcs:mark'

for vcs in $sm; do
    zstyle -s ':henchman:vcs:mark' $vcs mark
    zstyle ":vcs_info:${vcs}:henchman:*" formats $mark $format
    zstyle ":vcs_info:${vcs}:henchman:*" actionformats $mark $actionformat
done

# Make %u and %c useful: (potentially expensive)
zstyle ':vcs_info:*:henchman:*' check-for-changes true

# For %u and %c to work for mercurial, extra steps are required:
zstyle ':vcs_info:hg:henchman:*' get-revision true
zstyle ':vcs_info:hg:henchman:*' use-simple false # default, but why trust that?

# Make use of mercurial's local revision number
zstyle ':vcs_info:hg:henchman:*' hgrevformat '%r:%8.8h' # this is %i in formats
zstyle ':vcs_info:hg:henchman:*' hgrevformat '%r:' # this is %i in formats
zstyle ':vcs_info:hg:henchman:*' branchformat '%b(%r)'
zstyle ':vcs_info:hg:henchman:*' branchformat '%r%b'

# These need to have spaces, since they appear double-wide, except for new file
# Only in some fonts are they that way
#   staged:     red ●
# unstaged:    blue ✚
# all good:   green ✔
# new file: default …
#    ahead: default ↑
#   behind: default ↓
# diverged: default ↕
zstyle ':vcs_info:*:henchman:*' stagedstr "%F{$staged}%2{● %}%f"
zstyle ':vcs_info:*:henchman:*' unstagedstr "%F{$unstaged}%2{✚ %}%f"

# How to integrate checking for pushes/pulls server side? what hook?
#
# :vcs_info:vcs-string+hook-name:user-context:repo-root-name
# I would like to find a better hook, but I may not be able to.
#
# TODO: zsh_git_status recognises a new file as staged, but vcs_info doesn't (zsh v5.0.0)
zstyle ':vcs_info:git+set-message:henchman:*' hooks repo-status
zstyle ':vcs_info:hg+set-message:henchman:*'  hooks repo-status

function vcs_counts () {
    # use $hook_com[] as a vehicle, but prepend keys with hm_ to prevent collisions
    typeset -a st
    local line
    typeset -i staged unstaged untracked incoming outgoing

    case $hook_com[vcs] in
        git)
            st=(${(f)"$(git status --porcelain --branch 2>/dev/null)"})
            for line in $st; do
                [[ -n "$hm_DEBUG" ]] && print "Working on '$line':"
                # ;| causes following tests to be tried, as well
                case $line in
                    A*)  : $((staged++)) ;|
                    C*)  : $((staged++)) ;| # I don't know what "copied in index" means
                    D*)  : $((staged++)) ;|
                    M*)  : $((staged++)) ;|
                    R*)  : $((staged=staged+2)) ;| # R=A+D
                    ?M*) : $((unstaged++)) ;|
                    ?D*) : $((unstaged++)) ;;
                    '?? '*) : $((untracked++)) ;;
                    '## '*\[ahead*) outgoing=${${line##* \[ahead }%%(,*|\])} ;|
                    '## '*\[*behind*) incoming=${${line##*( \[|, )behind }%]} ;;
                esac
            done

        ;;
        hg)
            st=(${(f)"$(hg summary --remote 2>/dev/null)"})
            for line in $st; do
                [[ -n "$hm_DEBUG" ]] && print "Working on '$line':"
                line=${line//:}
                case $line in
                    commit*added*)    unstaged=${${line%% added*}##* }    ;|
                    commit*modified*) unstaged=${${line%% modified*}##* } ;|
                    commit*unknown*)  untracked=${${line%% unknown*}##* } ;;
                    remote*outgoing*) outgoing=${${line%% outgoing*}##* } ;|
                    remote*incoming*) incoming=${${line%% or more incoming*}##* } ;;
                esac
            done
            ;;
    esac

    user_data[hm_staged]=$staged
    user_data[hm_unstaged]=$unstaged
    user_data[hm_untracked]=$untracked
    user_data[hm_incoming]=$incoming
    user_data[hm_outgoing]=$outgoing

}

+vi-repo-status () {
    # redefine %c and %u:
    #  %c: repository state status (staged, changed, clean)
    #  %u: remote (ahead/behind)

    # Do we even want to get the repository status?
    zstyle -t  ":vcs_info:${hook_com[vcs]}:henchman:${hook_com[base-name]}" check-for-changes || return 0

    vcs_counts

    zstyle -s ':henchman:vcs:color:' staged staged_color
    zstyle -s ':henchman:vcs:color:' unstaged unstaged_color
    zstyle -s ':henchman:vcs:color:' clean clean_color

    local staged="%F{$staged_color}%2{● %}"
    local unstaged="%F{$unstaged_color}%2{✚ %}"
    local untracked='%1{…%}'
    local outgoing='%1{↑%}'
    local incoming='%1{↓%}'
    local clean="%B%F{$clean_color}%1{✔%}%f%b"
    local mess

    # (%u)pstream:
    mess=''
    if [[ $user_data[hm_incoming] -gt 0 ]]; then
        mess="$mess$incoming$user_data[hm_incoming]"
    fi
    if [[ $user_data[hm_outgoing] -gt 0 ]]; then
        mess="$mess$outgoing$user_data[hm_outgoing]"
    fi

    hook_com[unstaged]=$mess

    # (%c)hanges
    mess='|'
    if [[ $user_data[hm_staged] -gt 0 ]]; then
        mess="$mess$staged$user_data[hm_staged]%f"
    fi
    if [[ $user_data[hm_unstaged] -gt 0 ]]; then
        mess="$mess$unstaged$user_data[hm_unstaged]%f"
    fi
    if [[ $user_data[hm_untracked] -gt 0 ]]; then
        mess="$mess$untracked"
    fi
    if [[ $(( $user_data[hm_staged] + $user_data[hm_unstaged] + $user_data[hm_untracked] )) -eq 0 ]]; then
        mess="$mess$clean"
    fi

    hook_com[staged]=$mess
}

# % escapes:

# %! history number
# %# %(!.#.%%)
# %% %
# %( %(...) if/then/else
# %) )
# %* time (24 hours, with seconds)
# %. trailing commponent of $PWD
# %/ $PWD
# %< %<...< left truncation
# %> %>...> right truncation
# %? status code
# %@ time (am/pm)
# %a (action)
# %b (branch name)
# %b (branch: branch name)
# %b stop bold
# %B start bold
# %c (changes staged)
# %c (patch: number of unapplied patches)
# %c trailing commponent of $PWD with ~ contraction
# %C trailing commponent of $PWD
# %d $PWD
# %D %D{string} strftime
# %D date (yy-mm-dd)
# %E clear to end of line
# %f stop foreground color
# %F start foreground color
# %g (patch: names of active mq guards)
# %G (patch: number of active mq guards)
# %G glitch - specify width in %{...%}
# %h (hgrev: 40 byte hash)
# %h history number
# %i (identifier or revision)
# %i current line number $PS4
# %I current line number of current file $PS4
# %j number of jobs
# %k stop background color
# %K start background color
# %l line/tty
# %L $SHLVL
# %m (misc replacement [git/hg patch])
# %m hostname up to first .
# %M FQDN
# %n $USERNAME
# %n (patch: number of applied patches)
# %N name of current script / $0
# %p (patch: top patch applied [applied-string])
# %r (branch: current revision)
# %r (hgrev: local revision)
# %r (repository name)
# %R (repository base directory)
# %s (vcs in use)
# %s stop standout
# %S (subdirectory within repository)
# %S start standout
# %t time (am/pm)
# %T time (24hr)
# %u (patch: number of unapplied patches [unapplied-string])
# %u (unstaged changes)
# %u stop underline
# %U start underline
# %v $psvar
# %w date in day-dd
# %W date mm/dd/yy
# %x name of file with current source code executed
# %y tty w/o /dev
# %[ %[x...] left(x=<) or right (x=>) truncation
# %_ status of parser (if/for) $PS2
# %{ start literal escape
# %} stop literal escape
# %~ $PWD, with ~ contraction

# Available:
# %" Bad idea
# %&
# %' Bad idea
# %+
# %,
# %:
# %;
# %=
# %A
# %e
# %H
# %J
# %o
# %O
# %P
# %q
# %Q
# %V
# %X
# %Y
# %z
# %Z
# %\ Bad idea
# %]
# %^
# %` Bad idea
# %|
#
# vcs_info (action)formats % escapes:
# %s hook_com[vcs]
# %b hook_com[branch]
# %a hook_com[action]
# %i hook_com[revision]
# %c hook_com[staged]
# %u hook_com[unstaged]
# %R hook_com[base]
# %r hook_com[base-name]
# %S hook_com[subdir]
# %m hook_com[misc]

# vim:ft=zsh:ts=4:sw=4:et
