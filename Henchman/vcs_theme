#!/bin/echo Please use source 

print 'Setting up for vcs info themes'
setopt promptsubst
autoload -Uz vcs_info
function precmd() { vcs_info }

# colors!
# You can use names or numbers. I like names.
color_branch='magenta'
color_staged='red'
color_unstaged='blue'
color_clean='green'
color_action='cyan'

format="(%B%F{$color_branch}%b%f%%b"
change_format="(%B%F{$color_branch}%b%f%%b|"
actionformat="(%B%F{$color_branch}%b%f%%b|%F{$color_action}%a%f"
change_actionformat="(%B%F{$color_branch}%b%f%%b:%F{$color_action}%a%f|"
not_smart='[%s]-'
not_smart_mark='%1{·¥§%}'
no_vcs_mark='%#'
changes='%u%c%+'
no_changes='%{%}'
divergence='%^'
# default repo format:
zstyle ':vcs_info:*' max-exports 4
zstyle ':vcs_info:*' formats $not_smart_mark $not_smart$format $no_changes
zstyle ':vcs_info:*' actionformats $not_smart_mark $not_smart$actionformat $no_changes
zstyle ':vcs_info:*' nvcsformats $no_vcs_mark

# smart marks:
# We specify width, since some terminals get upset otherwise
typeset -A sm smc
sm[bzr]='%2{‚öØ %}'    # Bazaar       <http://bazaar-vcs.org/>
sm[cvs]='%1{‚ò§%}'     # Concurrent Versioning System <http://www.nongnu.org/cvs/>
sm[darcs]='%2{‚úº %}'  # Darcs        <http://darcs.net/>
sm[fossil]='%2{‚åò %}' # Fossil       <http://fossil-scm.org/>
smc[git]='%1{¬±%}'    # Git          <http://git-scm.com/>
smc[hg]='%1{‚òø%}'     # Mercurial    <http://mercurial.selenic.com/>
sm[mtn]='%2{üê≠ %}'    # Monotone     <http://monotone.ca/>
sm[p4]='%1{Íüº%}'      # Perforce     <http://www.perforce.com/>
sm[svn]='%1{‚Ä°%}'     # Subversion   <http://subversion.tigris.org/>
sm[tla]='%2{‚åí %}'    # GNU arch     <http://www.gnu.org/software/gnu-arch/>
# sm[cdv]=''         # Codeville    <http://codeville.org/>
# sm[svk]=''         # SVK          <http://svk.bestpractical.com/>

for vcs in ${(k)sm}; do
	zstyle ":vcs_info:$vcs:*" formats $sm[$vcs] $format $no_changes
	zstyle ":vcs_info:$vcs:*" actionformats $sm[$vcs] $actionformat $no_changes
done

for vcs in ${(k)smc}; do
	zstyle ":vcs_info:$vcs:*" formats $smc[$vcs] $change_format $changes $divergence
	zstyle ":vcs_info:$vcs:*" actionformats $smc[$vcs] $change_actionformat $changes $divergence
done

# Make %u and %c useful: (potentially expensive)
zstyle ':vcs_info:*' check-for-changes true

# For %u and %c to work for mercurial, extra steps are required:
zstyle ':vcs_info:hg:*' get-revision true
zstyle ':vcs_info:hg:*' use-simple false # default, but why trust that?

# Make use of mercurial's local revision number
zstyle ':vcs_info:hg:*' hgrevformat '%r:%8.8h' # this is %i in formats
zstyle ':vcs_info:hg:*' hgrevformat '%r' # this is %i in formats
zstyle ':vcs_info:hg:*' branchformat '%b(%r)'
zstyle ':vcs_info:hg:*' branchformat '%r:%b'

# These need to have spaces, since they appear double-wide, except for new file
# Only in some fonts are they that way
#   staged:     red ‚óè
# unstaged:    blue ‚úö
# all good:   green ‚úî
# new file: default ‚Ä¶
#    ahead: default ‚Üë
#   behind: default ‚Üì
# diverged: default ‚Üï
zstyle ':vcs_info:*' stagedstr "%F{$color_staged}%2{‚óè %}%f"
zstyle ':vcs_info:*' unstagedstr "%F{$color_unstaged}%2{‚úö %}%f"

# How to integrate checking for pushes/pulls server side? what hook?
#
# :vcs_info:vcs-string+hook-name:user-context:repo-root-name
# I would like to find a better hook, but I may not be able to.
#
# TODO: zsh_git_status recognises a new file as staged, but vcs_info doesn't (zsh v5.0.0)
zstyle ':vcs_info:git+set-message:*' hooks git-remote
function +vi-git-remote () {
	# %+ for untracked files
	# %^ for origin divergence

	case $1 in
		2)
			local st="$(git status --porcelain 2>/dev/null)"
			# I would like to use --porcelain -z, but the NULLs break the regex below
			# the following regex *can* run into problems, if a file is named with an embedded/
			# leading/trainling '?? ' string and that file is "of interest"
			local untracked='%1{‚Ä¶%}'
			if [[ ! $st =~ '\?\? ' ]]; then
				unset untracked
			fi
			local message=$2
			message=${message/\%u/$hook_com[unstaged]}
			message=${message/\%c/$hook_com[staged]}
			message=${message/\%+/$untracked}
			hook_com[message]="$message"
			ret=1
			;;
		3)
			# TODO: Combine both git calls into one
			typeset -a st_arr
			local st
			st="$(git status --porcelain --branch 2>/dev/null)"
			st_arr=(${(f)st})
			## master
			## master...origin/master [ahead 1]
			## master...origin/master [behind 1]
			## master...origin/master [ahead 1, behind 1]
			local ahead behind
			if [[ ! $st_arr[1] = ${st_arr[1]##*ahead} ]]; then
				local ahead_sigil='%1{‚Üë%}'
				ahead="$ahead_sigil${${st_arr[1]##* \[ahead }%%(,*|\])}"
			fi

			if [[ ! $st_arr[1] = ${st_arr[1]##*behind} ]]; then
				local behind_sigil='%1{‚Üì%}'
				behind="$behind_sigil${${st_arr[1]##*( \[|, )behind }%]}"
			fi
			hook_com[message]="$behind$ahead"
			ret=1
			;;
	esac
}

zstyle ':vcs_info:hg+set-message:*' hooks hg-remote
function +vi-hg-remote () {
	# %+ for untracked files
	# %^ for origin divergence

	# If we aren't checking for changes, skip everything
	zstyle -t ':vcs_info:hg:' check-for-changes || return 0

	case $1 in
		2)
			typeset -a st_arr
			local st="$(hg summary 2>/dev/null)"
			st_arr=(${(f)st})
			local untracked='%1{‚Ä¶%}'
			if [[ ${st_arr[4]} = ${st_arr[4]#*unknown} ]]; then
				untracked=''
			fi
			local message=$2
			message=${message/\%u/$hook_com[unstaged]}
			message=${message/\%c/$hook_com[staged]}
			message=${message/\%+/$untracked}
			hook_com[message]="$message"
			ret=1
			;;
		3)
			# we can get accurate counts for outgoing commits,
			# but "1 or more" estimates for incoming commits
			typeset -a st_arr
			local st="$(hg summary --remote 2>/dev/null)"
			st_arr=(${(f)st})
			local ahead ahead_sigil='%1{‚Üë%}'
			local behind behind_sigil='%1{‚Üì%}'

			local message=''
			if [[ -n ${st_arr[6]} ]]; then
				message=${st_arr[6]##remote: }
				if [[ ! ${st_arr[6]} = ${st_arr[6]#*outgoing} ]]; then
					ahead=$ahead_sigil
				fi
				if [[ ! ${st_arr[6]} = ${st_arr[6]#*incoming} ]]; then
					behind=$behind_sigil
				fi
			fi

			hook_com[message]=$behind$ahead
			ret=1
			;;
	esac
}

function vcs_counts () {
	# use $hook_com[] as a vehicle, but prepend keys with hm_ to prevent collisions
	typeset -a st
	local line
	typeset -i staged unstaged untracked incoming outgoing

	case $hook_com[vcs] in
		git)
			st=(${(f)"$(git status --porcelain --branch 2>/dev/null)"})
			for line in $st; do
				[[ -n "$hm_DEBUG" ]] && print "Working on '$line':"
				# ;| causes following tests to be tried, as well
				case $line in
					A*)  : $((staged++)) ;|
					D*)  : $((staged++)) ;|
					M*)  : $((staged++)) ;|
					R*)  : $((staged=staged+2)) ;|
					?M*) : $((unstaged++)) ;|
					?D*) : $((unstaged++)) ;;
					'?? '*) : $((untracked++)) ;;
					'## '*\[ahead*) outgoing=${${line##* \[ahead }%%(,*|\])} ;|
					'## '*\[*behind*) incoming=${${line##*( \[|, )behind }%]} ;;
				esac
			done

		;;
		hg)
			st=(${(f)"$(hg summary --remote 2>/dev/null)"})
			for line in $st; do
				[[ -n "$hm_DEBUG" ]] && print "Working on '$line':"
				line=${line//:}
				case $line in
					commit*added*) unstaged=${${line%% added*}##* } ;|
					commit*modified*) unstaged=${${line%% modified*}##* } ;|
					commit*unknown*) untracked=${${line%% unknown*}##* } ;;
					remote*outgoing*) outgoing=${${line%% outgoing*}##* } ;|
					remote*incoming*) incoming=${${line%% or more incoming*}##* } ;;
				esac
			done
			;;
	esac

	hook_com[hm_staged]=$staged
	hook_com[hm_unstaged]=$unstaged
	hook_com[hm_untracked]=$untracked
	hook_com[hm_incoming]=$incoming
	hook_com[hm_outgoing]=$outgoing

}
function vcs_counts_lastmsg () {
	printf 'staged=%i\nunstaged=%i\nuntracked=%i\noutgoing=%i\nincoming=%i\n' \
		$hook_com[hm_staged] \
		$hook_com[hm_unstaged] \
		$hook_com[hm_untracked] \
		$hook_com[hm_outgoing] \
		$hook_com[hm_incoming]
}
function vcs_prompt() {
	local staged="%F{red}%2{‚óè %}"
	local unstaged="%F{blue}%2{‚úö %}"
	local untracked='%1{‚Ä¶%}'
	local outgoing='%1{‚Üë%}'
	local incoming='%1{‚Üì%}'
	local clean='%F{green}%1{‚úî%}%f'
	local mess

	vcs_counts
	if [[ $hook_com[hm_incoming] -gt 0 ]]; then
		mess="$mess$incoming$hook_com[hm_incoming]"
	fi
	if [[ $hook_com[hm_outgoing] -gt 0 ]]; then
		mess="$mess$outgoing$hook_com[hm_outgoing]"
	fi

	mess="$mess|"

	if [[ $hook_com[hm_staged] -gt 0 ]]; then
		mess="$mess$staged$hook_com[hm_staged]%f"
	fi
	if [[ $hook_com[hm_unstaged] -gt 0 ]]; then
		mess="$mess$unstaged$hook_com[hm_unstaged]%f"
	fi
	if [[ $hook_com[hm_untracked] -gt 0 ]]; then
		mess="$mess$untracked"
	fi
	if [[ $(( $hook_com[hm_staged] + $hook_com[hm_unstaged] + $hook_com[hm_untracked] )) -eq 0 ]]; then
		mess="$mess$clean"
	fi

	print -P "$mess"
}

# To allow the green checkmarks to work, we need to define vcs_info_2_ to be a nonprinting
# non-null.  %{%} works for this purpos. Looks ugly, but it's the option
PS1='%F{5}[%F{2}%n%F{5}]%f %F{3}%3~%f ${vcs_info_msg_1_:+${vcs_info_msg_1_}${vcs_info_msg_3_}${vcs_info_msg_2_:-%F{green\}%1{‚úî%\}%f})}%B${vcs_info_msg_0_}%b '


# % escapes:

# %! history number
# %# %(!.#.%%)
# %% %
# %( %(...) if/then/else
# %) )
# %* time (24 hours, with seconds)
# %. trailing commponent of $PWD
# %/ $PWD
# %< %<...< left truncation
# %> %>...> right truncation
# %? status code
# %@ time (am/pm)
# %a (action)
# %b (branch name)
# %b (branch: branch name)
# %b stop bold
# %B start bold
# %c (changes staged)
# %c (patch: number of unapplied patches)
# %c trailing commponent of $PWD with ~ contraction
# %C trailing commponent of $PWD
# %d $PWD
# %D %D{string} strftime
# %D date (yy-mm-dd)
# %E clear to end of line
# %f stop foreground color
# %F start foreground color
# %g (patch: names of active mq guards)
# %G (patch: number of active mq guards)
# %G glitch - specify width in %{...%}
# %h (hgrev: 40 byte hash)
# %h history number
# %i (identifier or revision)
# %i current line number $PS4
# %I current line number of current file $PS4
# %j number of jobs
# %k stop background color
# %K start background color
# %l line/tty
# %L $SHLVL
# %m (misc replacement [git/hg patch])
# %m hostname up to first .
# %M FQDN
# %n $USERNAME
# %n (patch: number of applied patches)
# %N name of current script / $0
# %p (patch: top patch applied [applied-string])
# %r (branch: current revision)
# %r (hgrev: local revision)
# %r (repository name)
# %R (repository base directory)
# %s (vcs in use)
# %s stop standout
# %S (subdirectory within repository)
# %S start standout
# %t time (am/pm)
# %T time (24hr)
# %u (patch: number of unapplied patches [unapplied-string])
# %u (unstaged changes)
# %u stop underline
# %U start underline
# %v $psvar
# %w date in day-dd
# %W date mm/dd/yy
# %x name of file with current source code executed
# %y tty w/o /dev
# %[ %[x...] left(x=<) or right (x=>) truncation
# %_ status of parser (if/for) $PS2
# %{ start literal escape
# %} stop literal escape
# %~ $PWD, with ~ contraction

# Available:
# %" Bad idea
# %&
# %' Bad idea
# %+
# %,
# %:
# %;
# %=
# %A
# %e
# %H
# %J
# %o
# %O
# %P
# %q
# %Q
# %V
# %X
# %Y
# %z
# %Z
# %\ Bad idea
# %]
# %^
# %` Bad idea
# %|
